---
import { ViewTransitions } from 'astro:transitions';
import { SITE_CONFIG } from '../config/site';

interface Props {
	title: string;
	description?: string;
}

const { title, description = SITE_CONFIG.description } = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="description" content={description} />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
		<meta name="generator" content={Astro.generator} />
		<title>{title}</title>
		<ViewTransitions />
	</head>
	<body class="font-sans antialiased">
		<slot />
	</body>
</html>

<style is:global>
	/* Sistema de animaciones centralizado y sim√©trico */
	
	/* Base: Todos los elementos animables empiezan invisibles */
	.scroll-animate {
		opacity: 0;
		transform: translateY(30px);
		transition: opacity 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
		            transform 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);
		will-change: opacity, transform;
	}

	/* Estado visible - se aplica cuando el elemento entra al viewport */
	.scroll-animate.visible {
		opacity: 1;
		transform: translateY(0);
	}

	/* Variantes de delay para animaciones secuenciales */
	.scroll-animate[data-delay="1"] { transition-delay: 0.1s; }
	.scroll-animate[data-delay="2"] { transition-delay: 0.2s; }
	.scroll-animate[data-delay="3"] { transition-delay: 0.3s; }
	.scroll-animate[data-delay="4"] { transition-delay: 0.4s; }
	.scroll-animate[data-delay="5"] { transition-delay: 0.5s; }
	.scroll-animate[data-delay="6"] { transition-delay: 0.6s; }

	/* Compatibilidad con clases antiguas - migraci√≥n gradual */
	.scroll-fade-in {
		opacity: 0;
		transform: translateY(30px);
		transition: opacity 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94), 
		            transform 0.7s cubic-bezier(0.25, 0.46, 0.45, 0.94);
		will-change: opacity, transform;
	}

	.scroll-fade-in.visible {
		opacity: 1;
		transform: translateY(0);
	}

	/* Animaci√≥n de hover con efecto focus/shadow - sin elevaci√≥n */
	.hover-focus {
		transition: box-shadow 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
	}

	.hover-focus:hover {
		box-shadow: 0 0 0 4px rgba(104, 194, 140, 0.1),
		            0 8px 24px rgba(0, 0, 0, 0.12),
		            0 4px 8px rgba(0, 0, 0, 0.08);
	}

	/* Variante con color primario m√°s intenso */
	.hover-focus-primary {
		transition: box-shadow 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
	}

	.hover-focus-primary:hover {
		box-shadow: 0 0 0 3px rgba(104, 194, 140, 0.2),
		            0 12px 32px rgba(104, 194, 140, 0.15),
		            0 6px 12px rgba(0, 0, 0, 0.1);
	}

	/* Variante sutil para elementos blancos */
	.hover-focus-subtle {
		transition: box-shadow 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
	}

	.hover-focus-subtle:hover {
		box-shadow: 0 0 0 2px rgba(104, 194, 140, 0.08),
		            0 8px 20px rgba(0, 0, 0, 0.08),
		            0 4px 8px rgba(0, 0, 0, 0.04);
	}
</style>

<script is:inline>
	/**
	 * Sistema Global de Animaciones de Scroll v2.0
	 * - Sim√©trico: funciona en ambas direcciones (scroll up/down)
	 * - Robusto: detecta elementos sin importar d√≥nde se abre la p√°gina
	 * - Centralizado: f√°cil de mantener y configurar
	 */
	(function() {
		'use strict';

		// Configuraci√≥n centralizada
		const CONFIG = {
			selectors: '.scroll-animate, .scroll-fade-in',
			rootMargin: '100px', // Margen sim√©trico: detecta elementos 100px antes de entrar
			threshold: 0.1, // 10% del elemento debe ser visible
			reAnimate: false // false = anima solo una vez, true = anima cada vez que entra
		};

		// Verificar soporte de IntersectionObserver
		if (typeof IntersectionObserver === 'undefined') {
			// Fallback: mostrar todos los elementos inmediatamente
			document.querySelectorAll(CONFIG.selectors).forEach(el => {
				el.classList.add('visible');
			});
			return;
		}

		// Crear el observer con configuraci√≥n optimizada
		const observer = new IntersectionObserver((entries) => {
			entries.forEach(entry => {
				// Animar cuando el elemento entra al viewport (sin importar direcci√≥n)
				if (entry.isIntersecting) {
					// Ya fue animado? Si reAnimate es false, skip
					if (!CONFIG.reAnimate && entry.target.classList.contains('visible')) {
						return;
					}

					// Obtener delay del atributo data-delay o style
					let delay = 0;
					
					// Prioridad 1: data-delay attribute (m√°s limpio)
					const dataDelay = entry.target.getAttribute('data-delay');
					if (dataDelay) {
						delay = parseInt(dataDelay) * 100; // data-delay="1" = 100ms
					} else {
						// Prioridad 2: animation-delay en style inline (legacy)
						const style = entry.target.getAttribute('style');
						const delayMatch = style && style.match(/animation-delay:\s*(\d+)ms/);
						if (delayMatch) {
							delay = parseInt(delayMatch[1]);
						}
					}

					// Aplicar animaci√≥n con delay
					setTimeout(() => {
						entry.target.classList.add('visible');
						
						// Si reAnimate es false, dejar de observar despu√©s de animar
						if (!CONFIG.reAnimate) {
							observer.unobserve(entry.target);
						}
					}, delay);
				} else if (CONFIG.reAnimate) {
					// Si el elemento sale del viewport y reAnimate es true,
					// remover la clase visible para que se anime de nuevo
					entry.target.classList.remove('visible');
				}
			});
		}, {
			root: null,
			rootMargin: CONFIG.rootMargin,
			threshold: CONFIG.threshold
		});

		/**
		 * Inicializar animaciones
		 * Observa todos los elementos animables en la p√°gina
		 */
		function initScrollAnimations() {
			// Obtener todos los elementos animables
			const elements = document.querySelectorAll(CONFIG.selectors);
			
			// Observar cada elemento
			elements.forEach(el => {
				// Remover clase visible si reAnimate est√° activado
				if (CONFIG.reAnimate) {
					el.classList.remove('visible');
				}
				
				// Observar el elemento
				observer.observe(el);
			});

			// Log para debugging (comentar en producci√≥n)
			// console.log(`üé® Scroll Animations: Observing ${elements.length} elements`);
		}

		/**
		 * Limpiar observer antes de transiciones de p√°gina
		 */
		function cleanup() {
			observer.disconnect();
		}

		// Inicializar cuando el DOM est√© listo
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initScrollAnimations);
		} else {
			initScrollAnimations();
		}

		// Re-inicializar despu√©s de transiciones de p√°gina (Astro View Transitions)
		document.addEventListener('astro:page-load', initScrollAnimations);
		document.addEventListener('astro:before-preparation', cleanup);
	})();
</script>

